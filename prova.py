# -*- coding: utf-8 -*-
"""prova

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XJN0GYWcJdm3_vJ9w2NP4tQWgUiVu7OL

README

Descrição do problema:

Classificacao de imagens : Gatos e cachorros,utilizando um modelo de rede neural convolucional treinado no dataset CIFAR-10,foi aplicado técnicas de pré-processamento de imagens e validação;


Justificativa das técnicas utilizadas:

Dataset CIFAR-10: usado para treinar com maior precisao e qualidade.

CNN: essa rede convulacional e otima em processamento de imagens, tambem ja foi ultilizada em sala de aula, por obvio eu ja tenho uma experiencia previa com ela e foi por isso que eu a escolhi;

Pré-processamento: Redimensionamento, normalização para ter uma maior qualidade na validacao das imagens selecionadas;

Treino e teste separados : Para ter uma melhor qualidade na pesquisa;

Etapas realizadas:

Parte 1: Montagem do drive no colab;

Parte 2: Carreguei o dataset do cifar e normalizei os dados;

Parte 3:Construi a CNN com as camadas Conv2D, MaxPooling e Dense;

Parte 4: treinei o modelo com validação interna;

Parte 5: Avaliei o modelo treinado com o conjunto de teste do CIFAR-10 e observei a acurácia e perda;

Parte 6: Fiz o pré-processamento das imagens locais, com redimensionamento, filtro gaussiano e equalização  para melhorar a qualidade da imagem.

Parte 7: Separei as imagens locais em treino e teste, para garantir uma validação mais correta.

Parte 8: Treinei um modelo com as imagens locais e avaliei com relatório de classificação (precision, recall e f1-score).

Parte 9: Fiz a predição das imagens locais utilizando o modelo treinado com
CIFAR-10, para analisar como ele se comportaria com imagens reais fora do dataset.

Resultados obtidos:

O modelo treinado com CIFAR-10 atingiu uma acurácia de aproximadamente 71%.
O modelo treinado com as imagens locais de gatos e cachorros teve um desempenho de 100%.

Acredito que as curva de treino e validacao tiveram um bom desempenho com o passar das epocas.

Tempo total gasto:

Aproximadamente 2 horas e meia.


Dificuldades encontradas:

Poucas imagens locais,a validação não ficou tão robusta quanto poderia.

Demorou muito tempo para treinar o Cifar.

O aviso de UserWarning sobre o uso do input_shape → precisei ajustar utilizando a camada Input para evitar esse tipo de alerta.

 Predição com modelo CIFAR-10,esqueci de ter definido class_names, mas esta funcionando.

segue o link para o repositorio com readme:
"""

from google.colab import drive
drive.mount('/content/drive')

import os

print("Conteúdo de MyDrive:", os.listdir('/content/drive/MyDrive'))

prova_path = '/content/drive/MyDrive/Prova'
print("Conteúdo da pasta Prova:", os.listdir(prova_path))

imagens_path = prova_path + '/imagens'
print("Conteúdo da pasta imagens:", os.listdir(imagens_path))

import os
import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from tensorflow.keras.preprocessing import image

# --- CONFIG ---
IMG_SIZE_CIFAR = (32, 32)
IMG_SIZE_LOCAL = (128, 128)
BATCH_SIZE = 64
EPOCHS = 15

# Caminho da pasta imagens no Google Drive (gatos e cachorros)
DATA_DIR = '/content/drive/MyDrive/Prova/imagens'

# Classes usadas para imagens locais
local_class_names = ['gato', 'cachorro']

# 1) Carrega CIFAR-10
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.cifar10.load_data()

# Normaliza para [0,1]
x_train = x_train.astype('float32') / 255.0
x_test  = x_test.astype('float32') / 255.0

# Modelo CNN para CIFAR-10 (input 32x32)
model_cifar = models.Sequential([
    layers.Conv2D(32, (3,3), activation='relu', input_shape=IMG_SIZE_CIFAR + (3,)),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(128, (3,3), activation='relu'),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(10, activation='softmax')  # 10 classes CIFAR-10
])

model_cifar.compile(optimizer='adam',
                    loss='sparse_categorical_crossentropy',
                    metrics=['accuracy'])

print("Treinando modelo CIFAR-10...")
history_cifar = model_cifar.fit(
    x_train, y_train,
    epochs=EPOCHS,
    batch_size=BATCH_SIZE,
    validation_split=0.2
)

test_loss, test_acc = model_cifar.evaluate(x_test, y_test, verbose=2)
print(f"\nAcurácia no teste CIFAR-10: {test_acc:.4f}")

# --- PREPROCESSAMENTO IMAGENS LOCAIS ---

def preprocess_image(path):
    # Carrega imagem colorida
    img = cv2.imread(path)
    if img is None:
        raise ValueError(f"Imagem não carregada: {path}")
    # Redimensiona para 128x128
    img = cv2.resize(img, IMG_SIZE_LOCAL)
    # Aplica filtro gaussiano
    img = cv2.GaussianBlur(img, (5,5), 0)
    # Converte para tons de cinza
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Equaliza histograma
    equalized = cv2.equalizeHist(gray)
    # Para usar no modelo CNN precisamos de 3 canais, então replicamos o canal
    processed = cv2.merge([equalized, equalized, equalized])
    # Normaliza [0,1]
    processed = processed.astype('float32') / 255.0
    return processed

# 2) Carrega imagens locais (gatos e cachorros)
images = []
labels = []

for idx, cls in enumerate(local_class_names):
    folder = os.path.join(DATA_DIR, cls)
    if not os.path.exists(folder):
        print(f"[AVISO] Pasta não encontrada: {folder}")
        continue
    for fname in os.listdir(folder):
        if fname.lower().endswith(('.jpg', '.jpeg', '.png')):
            path = os.path.join(folder, fname)
            try:
                img = preprocess_image(path)
                images.append(img)
                labels.append(idx)
            except Exception as e:
                print(e)

images = np.array(images)
labels = np.array(labels)

print(f"Imagens carregadas: {images.shape[0]}")

# 3) Separa treino/teste 80% / 20%
x_train_local, x_test_local, y_train_local, y_test_local = train_test_split(
    images, labels, test_size=0.2, random_state=42, stratify=labels)

# 4) Define modelo CNN para as imagens locais (128x128)
model_local = models.Sequential([
    layers.Conv2D(32, (3,3), activation='relu', input_shape=IMG_SIZE_LOCAL + (3,)),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(128, (3,3), activation='relu'),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(len(local_class_names), activation='softmax')
])

model_local.compile(optimizer='adam',
                    loss='sparse_categorical_crossentropy',
                    metrics=['accuracy'])

print("\nTreinando modelo local (gatos e cachorros)...")
history_local = model_local.fit(
    x_train_local, y_train_local,
    epochs=EPOCHS,
    batch_size=8,
    validation_split=0.2
)

# 5) Avalia modelo local
y_pred_local = np.argmax(model_local.predict(x_test_local), axis=1)

print("\nRelatório de classificação (gatos e cachorros):")
print(classification_report(y_test_local, y_pred_local, target_names=local_class_names))

# 6) Função para predizer com modelo CIFAR-10 nas imagens locais (32x32)
def prediz_local_cifar(modelo, pasta, img_size=(32,32)):
    print("\nPredições do modelo CIFAR-10 em imagens locais:")
    for cls in local_class_names:
        folder = os.path.join(pasta, cls)
        if not os.path.exists(folder):
            continue
        for fname in os.listdir(folder):
            if not fname.lower().endswith(('.jpg', '.jpeg', '.png')):
                continue
            path = os.path.join(folder, fname)
            img = image.load_img(path, target_size=img_size)
            arr = image.img_to_array(img) / 255.0
            arr = np.expand_dims(arr, 0)
            probs = modelo.predict(arr, verbose=0)[0]
            pred_idx = np.argmax(probs)
            conf = probs[pred_idx]
            print(f"{cls}/{fname:20} → {class_names[pred_idx]} (Confiança={conf:.2f})")

# Prediz imagens locais com modelo CIFAR-10
prediz_local_cifar(model_cifar, DATA_DIR)

